!!!Action
[{TableOfContents }]\\

Action是Struts框架最基本的工作单元：当Struts框架接收到一个请求时，会将请求与所定义的Action名字进行匹配，当找到匹配的Action时，就根据Action的定义去处理该请求。

一个Action可以指定多个 [Result | Struts.Configure.Result]，多个 [Exception Handler| Struts.Configure.Exception] 及一个 [Interceptor | Struts.Configure.Interceptor]。

Action的Name属性是必须的，其它属性都可以省略。

如：
%%prettify 
{{{
<action name="Logon" class="tutorial.Logon">
  <result type="redirectAction">Menu</result>
  <result name="input">/Logon.jsp</result>
</action>
}}}
/%


!!Action Name
In a web application, the name attribute is matched as part of the location requested by a browser (or other HTTP client). The framework will drop the host and application name and the extension and match what's in the middle: the action name. So, a request for __http://www.planetstruts.org/struts2-mailreader/Welcome.do__  will map to the __Welcome__ action.

Within an application a link to an action is usually generated by a Struts Tag. The tag can specify the action by name, and the framework will render the default extension and anything else that is needed. Forms may also submit directly to a Struts Action name (rather than a "raw" URI).

%%prettify 
{{{
<s:form action="Hello">
    <s:textfield label="Please enter your name" name="name"/>
    <s:submit/>
</s:form>
}}}
/%

%%information
Always try to use camelcase action names (eg. createUser) or underscores (eg. my_action).\\
__Do not__ using dots (eg. create.user), dashes (eg. my-action) and/or slashes (eg. admin/home).
/%

!!Action Methods
The default entry method to the handler class is defined by the [Action interface|Struts.Code.ActionInterface].

Sometimes, developers like to create more than one entry point to an Action. For example, in the case of a data-access Action, a developer might want separate entry-points for create, retrieve, update, and delete. A different entry point can be specified by the method attribute.
%%prettify 
{{{
<action name="delete" class="example.CrudAction" method="delete">
    ...
}}}
/%

!!Wildcard Method
Many times, a set of action mappings will share a common pattern. For example, all your edit actions might start with the word "edit", and call the edit method on the Action class. The delete  actions might use the same pattern, but call the delete method instead.

Rather than code a separate mapping for each action class that uses this pattern, you can write it once as a wildcard mapping. 

%%prettify 
{{{
<action name="*Crud" class="example.Crud" method="{1}">
    ...
}}}
/%


Here, a reference to "editCrud" will call the edit method on an instance of the Crud Action class. Likewise, a reference to "deleteCrud" will call the delete method instead.

Another common approach is to postfix the method name and set it off with an exclamation point (aka "bang"), underscore, or other special character.
* "action=Crud_input"
* "action=Crud_delete"

To use a postfix wildcard, just move the asterisk and add an underscore.

%%prettify 
{{{
<action name="Crud_*" class="example.Crud" method="{1}">
}}}
/%

From the framework's perspective, a wildcard mapping creates a new "virtual" mapping with all the same attributes as a conventional, static mapping. As a result, you can use the expanded wildcard name as the name of validation, type conversion, and message resource files, just as if it were an Action name (which it is!).
* Crud_input-validation.xml
* Crud_delete-conversion.xml

!!ActionSupport Default
If the class attribute in an action mapping is left blank, the com.opensymphony.xwork2.ActionSupport  class is used as a default.
%%prettify 
{{{
<action name="Hello">
   // ...
</action>
}}}
/%
* The ActionSupport class has an execute method that returns "success" and an input method that returns "input".
* To specify a different class as the default Action class, set the default-class-ref package attribute. 

!!Post-Back Default
A good practice is to link to actions rather than pages. Linking to actions encapsulates which server page renders, and ensures that an Action class can fire before a page renders.

Another common workflow stategy is to first render a page using an alternate method, like input and then have it submit back to the default execute method.

Using these two strategies together creates an opportunity to use a "post-back" form that doesn't specify an action. The form simply submits back to the action that created it.

%%prettify 
{{{
<s:form>
    <s:textfield label="Please enter your name" name="name"/>
    <s:submit/>
</s:form>
}}}
/%

!!Action Default
Usually, if an action is requested, and the framework can't map the request to an action name, the result will be the usual "404 - Page not found" error. But, if you would prefer that an omnibus action handle any unmatched requests, you can specify a default action. If no other action matches, the default action is used instead.

%%prettify 
{{{
<package name="Hello" extends="action-default">
    <default-action-ref name="UnderConstruction"/>

    <action name="UnderConstruction">
        <result>/UnderConstruction.jsp</result>
    </action>

    ...
}}}
/%
There are no special requirements for the default action. Each package can have its own default action, but there should only be __one default action per namespace__.

!!Wildcard Default
Using wildcards is another approach to default actions. A wildcard action at the end of the configuration can be used to catch unmatched references. 
%%prettify 
{{{
<action name="*">
  <result>/{1}.jsp</result>
</action>
}}}
/%
When a new action is needed, just add a stub page.

%%warning
It's important to put a "catchall" wildcard mapping like this at the end of your configuration so it won't attempt to map every request!
/%

For more about using wildcards, see [Wildcard Mappings|Struts.Configure.WildcardMappings].

